[{"model": "problem.SpecialProgram", "fields": {"fingerprint": "88207e070259c1f2a00b9a47bff33e2307daf45a266086f6e7174b49ce8e975f", "builtin": true, "filename": "acmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <stdio.h>\n#include <math.h>\n\nconst double EPS = 1.5E-6;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two doubles, maximal absolute error = %.10f\", EPS);\n    registerTestlibCmd(argc, argv);\n    \n    double ja = ans.readDouble();\n    double pa = ouf.readDouble();\n\n    if (fabs(ja - pa) > EPS + 1E-15)\n        quitf(_wa, \"expected %.10f, found %.10f\", ja, pa);\n    \n    quitf(_ok, \"answer is %.10f\", ja);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "e8b1dd37648b5152ffb9c3b9f0cd09b491be08d6d4056e1923b3983e0b28d8b3", "builtin": true, "filename": "caseicmp.cpp", "lang": "cpp", "category": "checker", "code": "/**\n * Checker to compare output and answer in the form:\n *\n * Case 1: <number>\n * Case 2: <number>\n * ...\n * Case n: <number>\n *\n */\n\n#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nvector<long long> readStream(InStream& in, TResult pe)\n{\n    vector<long long> result;\n\n    for (int testCase = 1; !in.seekEof(); testCase++)\n    {\n        string caseStr = in.readToken();\n        if (caseStr != \"Case\")\n            quitf(pe, \"Expected 'Case' but found '%s' [test case %d]\", compress(caseStr).c_str(), testCase);\n\n        string numExpStr;\n        stringstream ss;\n        ss << testCase;\n        ss >> numExpStr;\n        numExpStr += \":\";\n        string numStr = in.readToken();\n        if (numExpStr != numStr)\n            quitf(pe, \"Expected '%s' but found '%s' [test case %d]\", compress(numExpStr).c_str(), compress(numStr).c_str(), testCase);\n\n        result.push_back(in.readLong());\n    }\n\n    return result;\n}\n\nint main(int argc, char* argv[])\n{\n    setName(\"Single int64 checker with testcase-support\");\n    registerTestlibCmd(argc, argv);\n\n    vector<long long> ja = readStream(ans, _fail);\n    vector<long long> pa = readStream(ouf, _pe);\n\n    forn(i, min(ja.size(), pa.size()))\n        if (ja[i] != pa[i])\n            quitf(_wa, \"Expected %s found %s [test case %d]\", vtos(ja[i]).c_str(), vtos(pa[i]).c_str(), i + 1);\n\n    if (ja.size() != pa.size())\n        quitf(_pe, \"Expected %u test case(s) but found %u\", (unsigned int)(ja.size()), (unsigned int)(pa.size()));\n\n    string message = format(\"%u case(s):\", (unsigned int)(ja.size()));\n    if (ja.size() <= 5)\n    {\n        forn(i, ja.size())\n            message += \" \" + vtos(ja[i]);\n    }\n    else\n    {\n        forn(i, 3)\n            message += \" \" + vtos(ja[i]);\n        message += \" ...\";\n        forn(i, 2)\n            message += \" \" + vtos(ja[ja.size() - 2 + i]);\n    }\n\n    quitf(_ok, \"%s\", message.c_str());\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "81ca3798d28f91742017afd71421e8455695d153d3cf382c228851d895643dbb", "builtin": true, "filename": "casencmp.cpp", "lang": "cpp", "category": "checker", "code": "/**\n * Checker to compare output and answer in the form:\n *\n * Case 1: <number> <number> <number> ... <number>\n * Case 2: <number> <number> <number> ... <number>\n * ...\n * Case n: <number> <number> <number> ... <number>\n *\n */\n\n#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nstring token;\n\nvector<long long> readStreamCase(InStream& in, TResult pe, int testCase, bool& prereadCase)\n{\n    if (!prereadCase)\n    {\n        string caseStr = in.readToken();\n        if (caseStr != \"Case\")\n            quitf(pe, \"Expected 'Case' but found '%s' [test case %d]\", compress(caseStr).c_str(), testCase);\n    }\n\n    string numExpStr;\n    stringstream ss;\n    ss << testCase;\n    ss >> numExpStr;\n    numExpStr += \":\";\n    string numStr = in.readToken();\n    if (numExpStr != numStr)\n        quitf(pe, \"Expected '%s' but found '%s' [test case %d]\", compress(numExpStr).c_str(), compress(numStr).c_str(), testCase);\n\n    vector<long long> result;\n    while (!in.seekEof())\n    {\n        in.readTokenTo(token);\n        if (token == \"Case\")\n        {\n            prereadCase = true;\n            break;\n        }\n\n        result.push_back(stringToLongLong(in, token.c_str()));\n    }\n\n    return result;\n}\n\nstring longLongsToString(const vector<long long>& a)\n{\n    if (a.empty())\n        return \"\\\"\\\" [size=0]\";\n    \n    string elems;\n    if (a.size() <= 5)\n    {\n        forn(i, a.size())\n            elems += vtos(a[i]) + \" \";\n    }\n    else\n    {\n        forn(i, 3)\n            elems += vtos(a[i]) + \" \";\n        elems += \"... \";\n        forn(i, 2)\n            elems += vtos(a[a.size() - 2 + i]) + \" \";\n    }\n\n    return format(\"\\\"%s\\\" [size=%u]\", trim(elems).c_str(), (unsigned int)(a.size()));\n}\n\nint main(int argc, char* argv[])\n{\n    setName(\"Many int64s checker with testcase-support\");\n    registerTestlibCmd(argc, argv);\n\n    int testCase = 0;\n\n    bool ansPrereadCase = false;\n    bool oufPrereadCase = false;\n\n    while (!ans.seekEof())\n    {\n        testCase++;\n\n        vector<long long> ja = readStreamCase(ans, _fail, testCase, ansPrereadCase);\n        vector<long long> pa = readStreamCase(ouf, _pe, testCase, oufPrereadCase);\n\n        if (ja != pa)\n        {\n            string js = longLongsToString(ja);\n            string ps = longLongsToString(pa);\n            quitf(_wa, \"Sequences differ: jury has %s, but participant has %s [test case %d]\", js.c_str(), ps.c_str(), testCase);\n        }\n    }\n\n    quitf(_ok, \"%d test cases(s)\", testCase);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "259dec0938980361eb8b6eaec0d605c21f3b9b4385801e948bf9a860ea9ea01d", "builtin": true, "filename": "casewcmp.cpp", "lang": "cpp", "category": "checker", "code": "/**\n * Checker to compare output and answer in the form:\n *\n * Case 1: <token> <token> ... <token>\n * Case 2: <token> <token> ... <token>\n * ...\n * Case n: <token> <token> ... <token>\n *\n */\n\n#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nstring token;\n\nvector<string> readStreamCase(InStream& in, TResult pe, int testCase, bool& prereadCase)\n{\n    if (!prereadCase)\n    {\n        string caseStr = in.readToken();\n        if (caseStr != \"Case\")\n            quitf(pe, \"Expected 'Case' but found '%s' [test case %d]\", compress(caseStr).c_str(), testCase);\n    }\n\n    string numExpStr;\n    stringstream ss;\n    ss << testCase;\n    ss >> numExpStr;\n    numExpStr += \":\";\n    string numStr = in.readToken();\n    if (numExpStr != numStr)\n        quitf(pe, \"Expected '%s' but found '%s' [test case %d]\", compress(numExpStr).c_str(), compress(numStr).c_str(), testCase);\n\n    vector<string> result;\n    while (!in.seekEof())\n    {\n        in.readTokenTo(token);\n        if (token == \"Case\")\n        {\n            prereadCase = true;\n            break;\n        }\n\n        result.push_back(token);\n    }\n\n    return result;\n}\n\nstring stringsToString(const vector<string>& a)\n{\n    if (a.empty())\n        return \"\\\"\\\" [size=0]\";\n    \n    string elems;\n    forn(i, a.size())\n        elems += a[i] + \" \";\n\n    return format(\"\\\"%s\\\" [size=%u]\", compress(trim(elems)).c_str(), (unsigned int)(a.size()));\n}\n\nint main(int argc, char* argv[])\n{\n    setName(\"Tokens checker with testcase-support\");\n    registerTestlibCmd(argc, argv);\n\n    int testCase = 0;\n\n    bool ansPrereadCase = false;\n    bool oufPrereadCase = false;\n\n    while (!ans.seekEof())\n    {\n        testCase++;\n\n        vector<string> ja = readStreamCase(ans, _fail, testCase, ansPrereadCase);\n        vector<string> pa = readStreamCase(ouf, _pe, testCase, oufPrereadCase);\n\n        if (ja != pa)\n        {\n            string js = stringsToString(ja);\n            string ps = stringsToString(pa);\n            quitf(_wa, \"Sequences differ: jury has %s, but participant has %s [test case %d]\", js.c_str(), ps.c_str(), testCase);\n        }\n    }\n\n    quitf(_ok, \"%d test cases(s)\", testCase);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "c845efa20b78e71656272333b571d966fb0d020d2deef295cb8d9cb39019cc93", "builtin": true, "filename": "dcmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <stdio.h>\n#include <math.h>\n\nconst double EPS = 1E-6;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two doubles, maximal absolute or relative error = %.10f\", EPS);\n    registerTestlibCmd(argc, argv);\n    \n    double ja = ans.readDouble();\n    double pa = ouf.readDouble();\n    \n    if (!doubleCompare(ja, pa, EPS))\n        quitf(_wa, \"expected %.10f, found %.10f\", ja, pa);\n    \n    quitf(_ok, \"answer is %.10f\", ja);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "3813d49afd13857026fcd4643f51689c39639f83c2b4136b8d95ed285510a00f", "builtin": true, "filename": "fcmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare files as sequence of lines\");\n    registerTestlibCmd(argc, argv);\n\n    std::string strAnswer;\n\n    int n = 0;\n    while (!ans.eof()) \n    {\n        std::string j = ans.readString();\n\n        if (j == \"\" && ans.eof())\n          break;\n\n        strAnswer = j;\n        std::string p = ouf.readString();\n\n        n++;\n\n        if (j != p)\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(), compress(j).c_str(), compress(p).c_str());\n    }\n    \n    if (n == 1)\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\n    \n    quitf(_ok, \"%d lines\", n);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "f259f8c6e80bdb794709c538d7fc10e50a4a27784892918f00422f7aa8bb8034", "builtin": true, "filename": "hcmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n\n#include <string>\n\nusing namespace std;\n\npattern pnum(\"0|-?[1-9][0-9]*\");\n\nbool isNumeric(const string& p)\n{\n    return pnum.matches(p);\n}\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two signed huge integers\");\n    registerTestlibCmd(argc, argv);\n    \n    string ja = ans.readWord();\n    string pa = ouf.readWord();\n\n    if (!isNumeric(ja))\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\n\n    if (!ans.seekEof())\n        quitf(_fail, \"expected exactly one token in the answer file\");\n    \n    if (!isNumeric(pa))\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\n\n    if (ja != pa)\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\n    \n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "8411f21edb41f83354647133499908f8df4b67f0d7083c9c818d5b7897cc8489", "builtin": true, "filename": "icmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <stdio.h>\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two signed int%ld's\", 8 * sizeof(int));\n    registerTestlibCmd(argc, argv);\n    \n    int ja = ans.readInt();\n    int pa = ouf.readInt();\n    \n    if (ja != pa)\n        quitf(_wa, \"expected %d, found %d\", ja, pa);\n    \n    quitf(_ok, \"answer is %d\", ja);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "9d52ff56949befa041778d235ee1bdfbd8f411ec5db2db8cf06362d317f12672", "builtin": true, "filename": "lcmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nbool compareWords(string a, string b)\n{\n    vector<string> va, vb;\n    stringstream sa;\n    \n    sa << a;\n    string cur;\n    while (sa >> cur)\n        va.push_back(cur);\n\n    stringstream sb;\n    sb << b;\n    while (sb >> cur)\n        vb.push_back(cur);\n\n    return (va == vb);\n}\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare files as sequence of tokens in lines\");\n    registerTestlibCmd(argc, argv);\n\n    std::string strAnswer;\n\n    int n = 0;\n    while (!ans.eof()) \n    {\n        std::string j = ans.readString();\n\n        if (j == \"\" && ans.eof())\n          break;\n        \n        std::string p = ouf.readString();\n        strAnswer = p;\n\n        n++;\n\n        if (!compareWords(j, p))\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(), compress(j).c_str(), compress(p).c_str());\n    }\n    \n    if (n == 1)\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\n    \n    quitf(_ok, \"%d lines\", n);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "f447b3249e895fc95dddc2bc420b0be073a941639bb4c13de5dc9d0065d99dc8", "builtin": true, "filename": "ncmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <sstream>\n\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare ordered sequences of signed int%ld numbers\", 8 * sizeof(long long));\n\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    string firstElems;\n\n    while (!ans.seekEof() && !ouf.seekEof())\n    {\n        n++;\n        long long j = ans.readLong();\n        long long p = ouf.readLong();\n        if (j != p)\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(), vtos(j).c_str(), vtos(p).c_str());\n        else\n            if (n <= 5)\n            {\n                if (firstElems.length() > 0)\n                    firstElems += \" \";\n                firstElems += vtos(j);\n            }\n    }\n\n    int extraInAnsCount = 0;\n\n    while (!ans.seekEof())\n    {\n        ans.readLong();\n        extraInAnsCount++;\n    }\n    \n    int extraInOufCount = 0;\n\n    while (!ouf.seekEof())\n    {\n        ouf.readLong();\n        extraInOufCount++;\n    }\n\n    if (extraInAnsCount > 0)\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\", n + extraInAnsCount, n);\n    \n    if (extraInOufCount > 0)\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\", n + extraInOufCount, n);\n    \n    if (n <= 5)\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\n    else\n        quitf(_ok, \"%d numbers\", n);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "d45ec4b3f1bec4345810b459b2b4a6b882acfc86ac4b6a27992cc99192c18d31", "builtin": true, "filename": "pointscmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    setName(\"example of scored checker\");\n    registerTestlibCmd(argc, argv);\n\n    double ja = ans.readDouble();\n    double pa = ouf.readDouble();\n\n    quitp(fabs(ja - pa), \"ja=%.4f pa=%.4f\", ja, pa);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "88207e070259c1f2a00b9a47bff33e2307daf45a266086f6e7174b49ce8e975f", "builtin": true, "filename": "rcmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <stdio.h>\n#include <math.h>\n\nconst double EPS = 1.5E-6;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two doubles, maximal absolute error = %.10f\", EPS);\n    registerTestlibCmd(argc, argv);\n    \n    double ja = ans.readDouble();\n    double pa = ouf.readDouble();\n\n    if (fabs(ja - pa) > EPS + 1E-15)\n        quitf(_wa, \"expected %.10f, found %.10f\", ja, pa);\n    \n    quitf(_ok, \"answer is %.10f\", ja);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "5a7a1f216b38ef1ca7a4f0ee63f657e342319e887998f998a0c33544195b4073", "builtin": true, "filename": "rcmp4.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1E-4;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    double j = 0, p = 0;\n\n    while (!ans.seekEof()) \n    {\n        n++;\n        j = ans.readDouble();\n        p = ouf.readDouble();\n        if (!doubleCompare(j, p, EPS))\n        {\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\n                n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\n        }\n    }\n\n    if (n == 1)\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\n    \n    quitf(_ok, \"%d numbers\", n);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "3bed9578a2c28fdf1f99d955be45f40dc8f3abe61bafac4bb6396c3677929008", "builtin": true, "filename": "rcmp6.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1E-6;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    double j = 0, p = 0;\n\n    while (!ans.seekEof()) \n    {\n        n++;\n        j = ans.readDouble();\n        p = ouf.readDouble();\n        if (!doubleCompare(j, p, EPS))\n        {\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\n                n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\n        }\n    }\n\n    if (n == 1)\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\n\n    quitf(_ok, \"%d numbers\", n);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "e6f149e94141198736b42f3489d89bafddabbfffce688b51a9751a2680646b3e", "builtin": true, "filename": "rcmp9.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1E-9;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    double j = 0, p = 0;\n\n    while (!ans.seekEof()) \n    {\n        n++;\n        j = ans.readDouble();\n        p = ouf.readDouble();\n        if (!doubleCompare(j, p, EPS))\n        {\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\n                n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\n        }\n    }\n\n    if (n == 1)\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\n\n    quitf(_ok, \"%d numbers\", n);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "1ee33cbce1247bf36b20bbc22e825b9215489c7b2e86889e9ab248d6c30ea2c8", "builtin": true, "filename": "rncmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1.5E-5;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two sequences of doubles, maximal absolute error = %.10f\", EPS);\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    while (!ans.seekEof()) \n    {\n        n++;\n        double j = ans.readDouble();\n        double p = ouf.readDouble();\n        if (fabs(j - p) > EPS + 1E-15)\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f'\", n, englishEnding(n).c_str(), j, p);\n    }\n\n    quitf(_ok, \"%d numbers\", n);\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "4afd04c48525c79cb1f317315a9c3f25f6c9415fed77b6b4e3cefddfe57fd469", "builtin": true, "filename": "uncmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <vector>\n\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare unordered sequences of signed int%lu numbers\", 8 * sizeof(long long));\n\n    registerTestlibCmd(argc, argv);\n\n    vector<long long> ja, pa;\n\n    while (!ans.seekEof())\n        ja.push_back(ans.readLong());\n\n    while (!ouf.seekEof())\n        pa.push_back(ouf.readLong());\n\n    if (ja.size() != pa.size())\n        quitf(_wa, \"Expected %u elements, but %u found\", (unsigned int)(ja.size()), (unsigned int)(pa.size()));\n\n    sort(ja.begin(), ja.end());\n    sort(pa.begin(), pa.end());\n\n    if (ja != pa)\n        quitf(_wa, \"Expected sequence and output are different (as unordered sequences) [size=%u]\", (unsigned int)(ja.size()));\n\n    string message;\n    \n    if (ja.size() != 1)\n        if (ja.empty())\n            message = \"empty sequence\";\n        else\n            message = vtos(ja.size()) + \" numbers (in increasing order):\";\n    else\n        message = vtos(ja.size()) + \" number:\";\n    \n    if (ja.size() <= 5)\n        for (int i = 0; i < min(int(ja.size()), 5); i++)\n            message += \" \" + vtos(ja[i]);\n    else\n    {\n        for (int i = 0; i < 2; i++)\n            message += \" \" + vtos(ja[i]);\n        message += \" ...\";\n        for (int i = 0; i < 2; i++)\n            message += \" \" + vtos(ja[ja.size() - 2 + i]);\n    }\n        \n    quitf(_ok, \"%s\", message.c_str());\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "bf438a1af053de984137aceea5e6f338c03b95eb0b54301e487f835748beada3", "builtin": true, "filename": "wcmp.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare sequences of tokens\");\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    string j, p;\n\n    while (!ans.seekEof() && !ouf.seekEof()) \n    {\n        n++;\n\n        ans.readWordTo(j);\n        ouf.readWordTo(p);\n        \n        if (j != p)\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(), compress(j).c_str(), compress(p).c_str());\n    }\n\n    if (ans.seekEof() && ouf.seekEof())\n    {\n        if (n == 1)\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\n        else\n            quitf(_ok, \"%d tokens\", n);\n    }\n    else\n    {\n        if (ans.seekEof())\n            quitf(_wa, \"Participant output contains extra tokens\");\n        else\n            quitf(_wa, \"Unexpected EOF in the participants output\");\n    }\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "a733ccc8918811528c1cdd629a27e711576c6ab9bb02f33ec029099eb9d9a830", "builtin": true, "filename": "yesno.cpp", "lang": "cpp", "category": "checker", "code": "#include \"testlib.h\"\n#include <string>\n\nusing namespace std;\n\nconst string YES = \"YES\";\nconst string NO = \"NO\";\n\nint main(int argc, char * argv[])\n{\n    setName(\"%s\", (YES + \" or \" + NO + \" (case insensetive)\").c_str());\n    registerTestlibCmd(argc, argv);\n\n    std::string ja = upperCase(ans.readWord());\n    std::string pa = upperCase(ouf.readWord());\n\n    if (ja != YES && ja != NO)\n        quitf(_fail, \"%s or %s expected in answer, but %s found\", YES.c_str(), NO.c_str(), compress(ja).c_str());\n\n    if (pa != YES && pa != NO)\n        quitf(_pe, \"%s or %s expected, but %s found\", YES.c_str(), NO.c_str(), compress(pa).c_str());\n\n    if (ja != pa)\n        quitf(_wa, \"expected %s, found %s\", compress(ja).c_str(), compress(pa).c_str());\n\n    quitf(_ok, \"answer is %s\", ja.c_str());\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "f498d2fd18a20dd8cbe061dbfc22a3a70d132535e12c6c265ffa371c80fb6cef", "builtin": true, "filename": "bgen.cpp", "lang": "cpp", "category": "generator", "code": "/*\n * Outputs random 100-digits binary string mostly containing 0's. \n * In average it contrains only 10% of 1's.\n *\n * To generate different values, call \"bgen.exe\" with different parameters.\n * \n * It is typical behaviour of testlib generator to setup randseed by command line.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    cout << rnd.next(\"[0000000001]{100}\") << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "05eda8d644ec79a2dba60e7bdbe209b9ae139f68b1eab7fe8caf19840e4a9427", "builtin": true, "filename": "gen-bipartite-graph.cpp", "lang": "cpp", "category": "generator", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = atoi(argv[1]);\n    int m = atoi(argv[2]);\n    size_t k = atoi(argv[3]);\n\n    int t = rnd.next(-2, 2);\n\n    set<pair<int,int> > edges;\n\n    while (edges.size() < k)\n    {\n        int a = rnd.wnext(n, t);\n        int b = rnd.wnext(m, t);\n        edges.insert(make_pair(a, b));\n    }\n\n    vector<pair<int,int> > e(edges.begin(), edges.end());\n    shuffle(e.begin(), e.end());\n\n    vector<int> pa(n);\n    for (int i = 0; i < n; i++)\n        pa[i] = i + 1;\n    shuffle(pa.begin(), pa.end());\n\n    vector<int> pb(m);\n    for (int i = 0; i < m; i++)\n        pb[i] = i + 1;\n    shuffle(pb.begin(), pb.end());\n\n    cout << n << \" \" << m << \" \" << e.size() << endl;\n\n    forn(i, e.size())\n        cout << pa[e[i].first] << \" \" << pb[e[i].second] << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "3335071f06f7c544f6c640db6982aa546a7efef9a6a1fc27a8095dc30f77a32f", "builtin": true, "filename": "gen-rooted-tree-graph.cpp", "lang": "cpp", "category": "generator", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = atoi(argv[1]);\n    int t = atoi(argv[2]);\n\n    vector<int> p(n);\n    forn(i, n)\n        if (i > 0)\n            p[i] = rnd.wnext(i, t);\n\n    printf(\"%d\\n\", n);\n    vector<int> perm(n);\n    forn(i, n)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    vector<int> pp(n);\n    for (int i = 1; i < n; i++)\n        pp[perm[i]] = perm[p[i]];\n\n    for (int i = 1; i < n; i++)\n    {\n        printf(\"%d\", pp[i] + 1);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "c1fe9f34bc57a0aeee89b34c80bf0ca534c9d84934c8aa6958ce508fdbb084fb", "builtin": true, "filename": "gen-tree-graph.cpp", "lang": "cpp", "category": "generator", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = atoi(argv[1]);\n    int t = atoi(argv[2]);\n\n    vector<int> p(n);\n    forn(i, n)\n        if (i > 0)\n            p[i] = rnd.wnext(i, t);\n\n    printf(\"%d\\n\", n);\n    vector<int> perm(n);\n    forn(i, n)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n    vector<pair<int,int> > edges;\n\n    for (int i = 1; i < n; i++)\n        if (rnd.next(2))\n            edges.push_back(make_pair(perm[i], perm[p[i]]));\n        else\n            edges.push_back(make_pair(perm[p[i]], perm[i]));\n\n    shuffle(edges.begin(), edges.end());\n\n    for (int i = 0; i + 1 < n; i++)\n        printf(\"%d %d\\n\", edges[i].first + 1, edges[i].second + 1);\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "1e07306eabd4a54f106f9164b4b25bfe6519057a773d92bf65ce81d210c05795", "builtin": true, "filename": "igen.cpp", "lang": "cpp", "category": "generator", "code": "/*\n * Outputs random number between 1 and 10^6, inclusive.\n * To generate different values, call \"igen.exe\" with different parameters.\n * For example, \"igen.exe 1\" returns 504077, but \"igen.exe 3\" returns 808747.\n * \n * It is typical behaviour of testlib generator to setup randseed by command line.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    cout << rnd.next(1, 1000000) << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "d928a24837d40daf99d4087ef64df154cb0a41f72c919862a44421407929add1", "builtin": true, "filename": "iwgen.cpp", "lang": "cpp", "category": "generator", "code": "/*\n * Outputs weighted random number between 1 and 10^6, inclusive.\n * To generate different values, call \"nwgen.exe weight\". \n *\n * If parameter \"weight\" \n * is equals to 0 than used uniformly distributed random.\n *\n * If parameter \"weight\" > 0 then you can think about it as code like this:\n * <code>\n * result = rnd.next(1, 1000000);\n * for (int i = 0; i < weight; i++)\n *     result = max(result, rnd.next(1, 1000000));\n * </code> \n * \n * If parameter \"weight\" < 0 then you can think about it as code like this:\n * <code>\n * result = rnd.next(1, 1000000);\n * for (int i = 0; i < -weight; i++)\n *     result = min(result, rnd.next(1, 1000000));\n * </code> \n *\n * It is typical behaviour of \"wnext\" methods to use this strategy to \n * generate off-center random distribution.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    cout << rnd.wnext(1, 1000000, atoi(argv[1])) << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "360a17b138a783c84c6d5e5c7ebfaddfebfa42d810bb8c59e051aebd83b389dd", "builtin": true, "filename": "multigen.cpp", "lang": "cpp", "category": "generator", "code": "/*\n * It is another type of generators. It writes several files named \n * as test indices. \n *\n * For example, this generator writes 10 files (tests) from 1 to 10.\n * This type of generators supported by Polygon too, but I believe \n * that stdout-generators are more preferred.\n *\n * The generator for A+B problem, generates 10 tests where each \n * number is between 1 and 100, and tests grow with indices.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nvoid writeTest(int test)\n{\n    startTest(test);\n    \n    cout << rnd.next(1, test * test) \n        << \" \" << rnd.next(1, test * test) << endl;\n}\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    for (int i = 1; i <= 10; i++)\n        writeTest(i);\n    \n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "735cf71cf58a56632392168a5cef3ebd7f95744e1824d4f265af92c2d617530a", "builtin": true, "filename": "sgen.cpp", "lang": "cpp", "category": "generator", "code": "/*\n * Outputs random token.\n *\n * Token contains latin letters and digits and have length \n * between 1 and 1000 characters, inclusive.\n *\n * To generate different values, call \"sgen.exe\" with different parameters.\n * \n * It is typical behaviour of testlib generator to setup randseed by command line.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    cout << rnd.next(\"[a-zA-Z0-9]{1,1000}\") << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "d03302a1c887322c169ca6dc6bf7db4fe3d6ed4a500a0e60d95ef3fb418d70b1", "builtin": true, "filename": "swgen.cpp", "lang": "cpp", "category": "generator", "code": "/*\n * Outputs random token.\n *\n * Token contains latin letters and digits and have length \n * between 1 and 1000 characters, inclusive.\n *\n * To generate different values, call \"swgen.exe <weight>\".\n * See \"iwgen.cpp\" and \"wnext()\" documentation for details.\n * For example, \"swgen.exe -1000\" generates short strings and \"swgen.exe 1000\"\n * generates long strings.\n * \n * It is typical behaviour of testlib generator to setup randseed by command line.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int length = rnd.wnext(1, 1000, atoi(argv[1]));\n    cout << rnd.next(\"[a-zA-Z0-9]{1,%d}\", length) << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "c896d22e13812a8ecc101dafbfb4e4ee36b7f8a7f90a9c55b842cef2db7a1c51", "builtin": true, "filename": "bipartite-graph-validator.cpp", "lang": "cpp", "category": "validator", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 400, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 400, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * m, \"k\");\n    inf.readEoln();\n\n    set<pair<int,int> > edges;\n\n    forn(i, k)\n    {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b_i\");\n        inf.readEoln();\n\n        ensuref(edges.count(make_pair(a, b)) == 0, \"Graph can't contain multiple edges between a pair of vertices\");\n        edges.insert(make_pair(a, b));\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "7c526bbf103586d6a677230965424d2129622fe70cb3187284196e0f6792af78", "builtin": true, "filename": "ival.cpp", "lang": "cpp", "category": "validator", "code": "/**\n * Validates that input contains the only integer between 1 and 100, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "5aec7d4dd493794485c1ed1451a3750c1920d804535a6f276862dc76de89f8d6", "builtin": true, "filename": "nval.cpp", "lang": "cpp", "category": "validator", "code": "/**\n * Validates that the first line contains the integer between 1 and 10^5, inclusive.\n * The second line should contains space-separated sequence of integers between -10^15 and 10^15, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++)\n    {\n        inf.readLong(-1000000000000000LL, 1000000000000000LL, format(\"a[%d]\", i + 1));\n\n        if (i + 1 < n)\n            inf.readSpace();\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "26ddaa0f5b6ae9e79d99a773c3b7a16520beb2eb45daf931eae427ecdac10282", "builtin": true, "filename": "sval.cpp", "lang": "cpp", "category": "validator", "code": "/**\n * Validates that the input contains the only token token.\n * This token can contain only lowercase latin letters a-z. The length should be between 1 and 100, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    \n    inf.readToken(\"[a-z]{1,100}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "f0c4f059b9dea82b883b7c1b26d2abf1ee3fcc86b6ad6208eaba07d3d1008903", "builtin": true, "filename": "undirected-graph-validator.cpp", "lang": "cpp", "category": "validator", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int> > edges;\n\n    forn(i, m)\n    {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Graph can't contain loops\");\n        ensuref(edges.count(make_pair(a, b)) == 0, \"Graph can't contain multiple edges between a pair of vertices\");\n\n        edges.insert(make_pair(a, b));\n        edges.insert(make_pair(b, a));\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "d2da4d553daf5c3100dfe5417f414a8a548dafbade66f08724fc4fca8ddbfb65", "builtin": true, "filename": "undirected-tree-validator.cpp", "lang": "cpp", "category": "validator", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint leader(vector<int>& dsu, int idx)\n{\n    return dsu[idx] == idx ? dsu[idx] : (dsu[idx] = leader(dsu, dsu[idx]));\n}\n\nbool merge(vector<int>& dsu, int a, int b)\n{\n    a = leader(dsu, a);\n    b = leader(dsu, b);\n    if (a == b)\n        return false;\n    else\n    {\n        if (rnd.next(2) == 0)\n            dsu[a] = b;\n        else\n            dsu[b] = a;\n        return true;\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> dsu(n);\n    forn(i, n)\n        dsu[i] = i;\n\n    set<pair<int,int> > edges;\n\n    forn(i, n - 1)\n    {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Tree can't contain loops\");\n        ensuref(edges.count(make_pair(x, y)) == 0, \"Tree can't contain multiple edges between a pair of vertices\");\n\n        edges.insert(make_pair(x, y));\n        edges.insert(make_pair(y, x));\n\n        ensuref(merge(dsu, x - 1, y - 1), \"Tree can't contain cycles\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "661ddb6f054750719ff8c8c220474f184b4a1b47f452a3a54dbba87b331dd966", "builtin": true, "filename": "validate-using-testset-and-group.cpp", "lang": "cpp", "category": "validator", "code": "/**\n * Validates that input depenging on testset and group.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n, m;\n\n    if (validator.testset() == \"pretests\")\n    {\n        n = inf.readInt(1, 10, \"n\");\n        inf.readSpace();\n        m = inf.readInt(1, 10, \"m\");\n    }\n    else\n    {\n        n = inf.readInt(1, 100, \"n\");\n        inf.readSpace();\n        m = inf.readInt(1, 100, \"m\");\n    }\n\n    if (validator.group() == \"even-n-and-m\")\n    {\n        ensure(n % 2 == 0);\n        ensure(m % 2 == 0);\n    }\n\n    inf.readEoln();\n    inf.readEof();\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "c896d22e13812a8ecc101dafbfb4e4ee36b7f8a7f90a9c55b842cef2db7a1c51", "builtin": true, "filename": "bipartite-graph-validator.cpp", "lang": "cpp", "category": "validator", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 400, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 400, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * m, \"k\");\n    inf.readEoln();\n\n    set<pair<int,int> > edges;\n\n    forn(i, k)\n    {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b_i\");\n        inf.readEoln();\n\n        ensuref(edges.count(make_pair(a, b)) == 0, \"Graph can't contain multiple edges between a pair of vertices\");\n        edges.insert(make_pair(a, b));\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "7c526bbf103586d6a677230965424d2129622fe70cb3187284196e0f6792af78", "builtin": true, "filename": "ival.cpp", "lang": "cpp", "category": "validator", "code": "/**\n * Validates that input contains the only integer between 1 and 100, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "5aec7d4dd493794485c1ed1451a3750c1920d804535a6f276862dc76de89f8d6", "builtin": true, "filename": "nval.cpp", "lang": "cpp", "category": "validator", "code": "/**\n * Validates that the first line contains the integer between 1 and 10^5, inclusive.\n * The second line should contains space-separated sequence of integers between -10^15 and 10^15, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++)\n    {\n        inf.readLong(-1000000000000000LL, 1000000000000000LL, format(\"a[%d]\", i + 1));\n\n        if (i + 1 < n)\n            inf.readSpace();\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "26ddaa0f5b6ae9e79d99a773c3b7a16520beb2eb45daf931eae427ecdac10282", "builtin": true, "filename": "sval.cpp", "lang": "cpp", "category": "validator", "code": "/**\n * Validates that the input contains the only token token.\n * This token can contain only lowercase latin letters a-z. The length should be between 1 and 100, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    \n    inf.readToken(\"[a-z]{1,100}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "f0c4f059b9dea82b883b7c1b26d2abf1ee3fcc86b6ad6208eaba07d3d1008903", "builtin": true, "filename": "undirected-graph-validator.cpp", "lang": "cpp", "category": "validator", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int> > edges;\n\n    forn(i, m)\n    {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Graph can't contain loops\");\n        ensuref(edges.count(make_pair(a, b)) == 0, \"Graph can't contain multiple edges between a pair of vertices\");\n\n        edges.insert(make_pair(a, b));\n        edges.insert(make_pair(b, a));\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "d2da4d553daf5c3100dfe5417f414a8a548dafbade66f08724fc4fca8ddbfb65", "builtin": true, "filename": "undirected-tree-validator.cpp", "lang": "cpp", "category": "validator", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint leader(vector<int>& dsu, int idx)\n{\n    return dsu[idx] == idx ? dsu[idx] : (dsu[idx] = leader(dsu, dsu[idx]));\n}\n\nbool merge(vector<int>& dsu, int a, int b)\n{\n    a = leader(dsu, a);\n    b = leader(dsu, b);\n    if (a == b)\n        return false;\n    else\n    {\n        if (rnd.next(2) == 0)\n            dsu[a] = b;\n        else\n            dsu[b] = a;\n        return true;\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> dsu(n);\n    forn(i, n)\n        dsu[i] = i;\n\n    set<pair<int,int> > edges;\n\n    forn(i, n - 1)\n    {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Tree can't contain loops\");\n        ensuref(edges.count(make_pair(x, y)) == 0, \"Tree can't contain multiple edges between a pair of vertices\");\n\n        edges.insert(make_pair(x, y));\n        edges.insert(make_pair(y, x));\n\n        ensuref(merge(dsu, x - 1, y - 1), \"Tree can't contain cycles\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.SpecialProgram", "fields": {"fingerprint": "661ddb6f054750719ff8c8c220474f184b4a1b47f452a3a54dbba87b331dd966", "builtin": true, "filename": "validate-using-testset-and-group.cpp", "lang": "cpp", "category": "validator", "code": "/**\n * Validates that input depenging on testset and group.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n, m;\n\n    if (validator.testset() == \"pretests\")\n    {\n        n = inf.readInt(1, 10, \"n\");\n        inf.readSpace();\n        m = inf.readInt(1, 10, \"m\");\n    }\n    else\n    {\n        n = inf.readInt(1, 100, \"n\");\n        inf.readSpace();\n        m = inf.readInt(1, 100, \"m\");\n    }\n\n    if (validator.group() == \"even-n-and-m\")\n    {\n        ensure(n % 2 == 0);\n        ensure(m % 2 == 0);\n    }\n\n    inf.readEoln();\n    inf.readEof();\n}\n"}}]